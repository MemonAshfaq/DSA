String Interview Tricks Cheat Sheet
==================================

1. Basic Operations
   - Reverse: s[::-1]
   - Palindrome: s == s[::-1]
   - Character counts: Counter(s)
   - ASCII conversions: ord(ch), chr(num)

2. Anagram Tricks
   - Sort & compare: sorted(s1) == sorted(s2)
   - Counter compare: Counter(s1) == Counter(s2)

3. Substring / Subsequence
   - Generate all substrings:
       for i in range(n):
           for j in range(i, n):
               sub = s[i:j+1]
   - Check subsequence:
       it = iter(t)
       all(c in it for c in s)

4. Sliding Window
   - Longest substring without repeat:
       seen, left, best = {}, 0, 0
       for right, ch in enumerate(s):
           if ch in seen and seen[ch] >= left:
               left = seen[ch] + 1
           seen[ch] = right
           best = max(best, right-left+1)

   - Min window substring:
       Expand right, shrink left while condition holds

5. Two-Pointer Tricks
   - Valid palindrome ignoring non-alphanum:
       i, j = 0, len(s)-1
       while i < j:
           if not s[i].isalnum(): i += 1; continue
           if not s[j].isalnum(): j -= 1; continue
           if s[i].lower() != s[j].lower(): return False
           i += 1; j -= 1
       return True

6. Prefix / Suffix
   - Longest common prefix:
       prefix, suffix = min(strs), max(strs)
       while not suffix.startswith(prefix):
           prefix = prefix[:-1]

7. Hashing / Rolling Hash
   - Rabin-Karp for substring search (efficient with hashing).

8. Dynamic Programming
   - Edit distance (Levenshtein)
   - Longest Common Subsequence (LCS)
   - Longest Palindromic Substring

9. Regex Handy Cases
   - Split multiple delimiters: re.split(r'[ ,;]', s)
   - Find all numbers: re.findall(r'\d+', s)

10. Memory Hooks
   - Two-pointer → palindrome & subsequence
   - Sliding window → substring with conditions
   - Hash map → unique substring/frequency
   - DP → transforms or compares two strings